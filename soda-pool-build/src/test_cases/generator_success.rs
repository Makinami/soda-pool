# ! [allow (clippy :: unit_arg , clippy :: clone_on_copy ,)] use super :: health :: * ; pub mod health_client { use super :: super :: health :: health_client :: * ; # [derive (Clone)] pub struct HealthClientPool { pool : std :: sync :: Arc < dyn soda_pool :: ChannelPool + Send + Sync > , } impl HealthClientPool { pub fn new (pool : impl soda_pool :: ChannelPool + Send + Sync + 'static) -> Self { Self { pool : std :: sync :: Arc :: new (pool) } } pub fn new_from_endpoint (endpoint : soda_pool :: EndpointTemplate) -> Self { Self { pool : std :: sync :: Arc :: new (soda_pool :: ManagedChannelPoolBuilder :: new (endpoint) . build ()) , } } } impl HealthClientPool { pub async fn is_alive (& self , request : impl tonic :: IntoRequest < () > ,) -> std :: result :: Result < tonic :: Response < super :: IsAliveResponse > , tonic :: Status > { self . is_alive_with_retry :: < soda_pool :: DefaultRetryPolicy > (request) . await } pub async fn is_alive_with_retry < RP : soda_pool :: RetryPolicy > (& self , request : impl tonic :: IntoRequest < () > ,) -> std :: result :: Result < tonic :: Response < super :: IsAliveResponse > , tonic :: Status > { let (metadata , extensions , message) = request . into_request () . into_parts () ; let mut tries = 0 ; loop { tries += 1 ; let (ip_address , channel) = self . pool . get_channel () . await . ok_or_else (|| { tonic :: Status :: unavailable ("No ready channels") }) ? ; let request = tonic :: Request :: from_parts (metadata . clone () , extensions . clone () , message . clone () ,) ; let result = HealthClient :: new (channel) . is_alive (request) . await ; match result { Ok (response) => { return Ok (response) ; } Err (e) => { let (server_status , retry_time) = RP :: should_retry (& e , tries) ; if matches ! (server_status , soda_pool :: ServerStatus :: Dead) { self . pool . report_broken (ip_address) . await ; } match retry_time { soda_pool :: RetryTime :: DoNotRetry => { return Err (e) ; } soda_pool :: RetryTime :: Immediately => { continue ; } soda_pool :: RetryTime :: After (duration) => { soda_pool :: deps :: sleep (duration) . await ; } } } } } } } } pub mod echo_client { use super :: super :: health :: echo_client :: * ; # [derive (Clone)] pub struct EchoClientPool { pool : std :: sync :: Arc < dyn soda_pool :: ChannelPool + Send + Sync > , } impl EchoClientPool { pub fn new (pool : impl soda_pool :: ChannelPool + Send + Sync + 'static) -> Self { Self { pool : std :: sync :: Arc :: new (pool) } } pub fn new_from_endpoint (endpoint : soda_pool :: EndpointTemplate) -> Self { Self { pool : std :: sync :: Arc :: new (soda_pool :: ManagedChannelPoolBuilder :: new (endpoint) . build ()) , } } } impl EchoClientPool { pub async fn echo_message (& self , request : impl tonic :: IntoRequest < super :: EchoRequest > ,) -> std :: result :: Result < tonic :: Response < super :: EchoResponse > , tonic :: Status > { self . echo_message_with_retry :: < soda_pool :: DefaultRetryPolicy > (request) . await } pub async fn echo_message_with_retry < RP : soda_pool :: RetryPolicy > (& self , request : impl tonic :: IntoRequest < super :: EchoRequest > ,) -> std :: result :: Result < tonic :: Response < super :: EchoResponse > , tonic :: Status > { let (metadata , extensions , message) = request . into_request () . into_parts () ; let mut tries = 0 ; loop { tries += 1 ; let (ip_address , channel) = self . pool . get_channel () . await . ok_or_else (|| { tonic :: Status :: unavailable ("No ready channels") }) ? ; let request = tonic :: Request :: from_parts (metadata . clone () , extensions . clone () , message . clone () ,) ; let result = EchoClient :: new (channel) . echo_message (request) . await ; match result { Ok (response) => { return Ok (response) ; } Err (e) => { let (server_status , retry_time) = RP :: should_retry (& e , tries) ; if matches ! (server_status , soda_pool :: ServerStatus :: Dead) { self . pool . report_broken (ip_address) . await ; } match retry_time { soda_pool :: RetryTime :: DoNotRetry => { return Err (e) ; } soda_pool :: RetryTime :: Immediately => { continue ; } soda_pool :: RetryTime :: After (duration) => { soda_pool :: deps :: sleep (duration) . await ; } } } } } } } }
