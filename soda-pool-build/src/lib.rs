#![cfg_attr(coverage_nightly, feature(coverage_attribute))]

use std::{
    fs,
    path::{Path, PathBuf},
};

mod error;
pub use error::*;

mod parser;
use parser::parse_grpc_client_file;

mod generator;
mod model;

/// Create a default [`SodaPoolBuilder`].
// Emulates the `tonic_build` interface.
#[must_use]
pub fn configure() -> SodaPoolBuilder {
    SodaPoolBuilder { dir: None }
}

/// Pooled gRPC clients generator.
#[derive(Debug)]
pub struct SodaPoolBuilder {
    dir: Option<PathBuf>,
}

impl SodaPoolBuilder {
    /// Set the input/output directory of gRPC clients' files.
    #[must_use]
    pub fn dir(mut self, dir: impl AsRef<Path>) -> Self {
        self.dir = Some(dir.as_ref().to_path_buf());
        self
    }

    /// Build pooled gRPC clients.
    ///
    /// Generate pooled version of gRPC clients from the specified files.
    /// `services` should be a list of files (with or without `.rs` extension)
    /// containing the original gRPC client code. Files will be searched in the
    /// directory specified by `dir`. For each input file, a new file will be
    /// created with the same name but with `_pool` suffix.
    ///
    /// # Errors
    /// Will return [`BuilderError`] on any errors encountered during pooled clients generation.
    #[allow(clippy::missing_panics_doc)]
    pub fn build_pools(&self, services: &[impl AsRef<str>]) -> BuilderResult<()> {
        let dir = self
            .dir
            .as_ref()
            .ok_or_else(|| BuilderError::missing_configuration("dir"))?;

        services.iter().try_for_each(|service| {
            let service_filename = if Path::new(service.as_ref())
                .extension()
                .is_some_and(|ext| ext.eq_ignore_ascii_case("rs"))
            {
                service.as_ref().to_string()
            } else {
                format!("{}.rs", service.as_ref())
            };

            let service_file = dir.join(&service_filename);
            let service_file_structure = parse_grpc_client_file(&service_file)?;

            let output = service_file_structure.generate_pooled_version();
            let file = syn::parse2(output)?;
            let formatted = format!(
                "// This file is @generated by soda-pool-build.\n{}",
                prettyplease::unparse(&file),
            );

            let output_file = {
                let mut filename = service_file
                .file_stem()
                .expect("`service_file` is already certain to hold path to a file by previous check")
                .to_owned();
                filename.push("_pool.rs");
                service_file.with_file_name(filename)
            };

            fs::write(output_file, formatted).unwrap();

            Ok(())
        })
    }
}
